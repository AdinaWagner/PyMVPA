From 391acd8463d23b171f7fb32731f6a015de8265f4 Mon Sep 17 00:00:00 2001
From: Yaroslav Halchenko <debian@onerussian.com>
Date: Tue, 17 Oct 2017 22:40:15 -0400
Subject: [PATCH 2/2] BF(thanks stringent numpy):  deal with a composite mask
 (one per x, one per y) for scatter_plot

before numpy allowed the selection mask being smaller than actual
array, e.g.

np.arange(5)[np.array([True, False, True])]

which is not entirely kosher.  And in our case if both masks were
provided it did something not entirely kosher I think
Now it should join both masks into intersection first
---
 mvpa2/misc/plot/scatter.py | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/mvpa2/misc/plot/scatter.py b/mvpa2/misc/plot/scatter.py
index c0a2b329..3d2f7ecb 100755
--- a/mvpa2/misc/plot/scatter.py
+++ b/mvpa2/misc/plot/scatter.py
@@ -134,6 +134,18 @@ def plot_scatter(dataXd, mask=None, masked_opacity=0.,
     x, y = datainter = data[:, intersection]
 
     if mask is not None:
+        if mask.size * ntimepoints == intersection.size:
+            # we have got a single mask applicable to both x and y
+            pass
+        elif mask.size * ntimepoints == 2 * intersection.size:
+            # we have got a mask per each, let's get an intersection
+            assert mask.shape[0] == 2, "had to get 1 for x, 1 for y"
+            mask = np.logical_and(mask[0], mask[1])
+        else:
+            raise ValueError(
+                "mask of shape %s. data of shape %s. ntimepoints=%d.  "
+                "Teach me how to apply it" % (mask.shape, data.shape, ntimepoints)
+            )
         # replicate mask ntimepoints times
         mask = np.repeat(mask.ravel(), ntimepoints)[intersection] != 0
         x_masked = x[mask]
-- 
2.14.1

